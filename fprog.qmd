# Functional programming

This chapter will teach you the fundamentals of functional programming. *Functional programming* might
sound scary, but we will focus on only a handful of concepts that are quite accessible while providing
many benefits. Using these functional programming concepts will make your code more reliable, easier
to test, document, share, and ultimately rerun.

## Introduction

You are very likely already familiar with some aspects of functional program. Let's start by discussing
the two central elements of functional programming: functions and lists.

There are several ways that you can structure a program, called programming paradigms. Functional programming
is a paradigm that relies exclusively on the evaluation of functions to achieve the desired end result. If you
have already written your own functions in the past, what follows will not be very new. But in order to write
a good functional program, the functions that you write and evaluate have to have certain properties. Before
discussing these properties, let's start by with *state*.

### The state of your program

Let's suppose that you start a fresh R session, and
immediately run this next line:

```{r, eval = F}
ls()
```

If you did not modify any of R's configuration files
that get automatically loaded on startup, you should
see the following:

```{r, eval = F}
character(0)
```

Let's suppose that now you load some data:

```{r, eval = F}
data(mtcars)
```

and define a variable `a`:

```{r, eval = F}
a <- 1
```

Running `ls()` now shows the following:

```{r, eval = F}
[1] "a"      "mtcars"
```

You have just altered the state of your program. You can think of the *state* as a box that holds everything
that gets defined by the user and is accessible at any time. Let's now define a simple function that
prints a sentence:

```{r, eval = F}
f <- function(name){
  print(paste0(name, " likes lasagna"))
}

f("Bruno")
```

and here's the output:

```{r, eval = F}
[1] "Bruno likes lasagna"
```

Let's run `ls()` again:

```{r, eval = F}
[1] "a"      "f"      "mtcars"
```

Function `f()` is now listed there as well. This function has two nice properties:

- For a given input, it always returns exactly the same output. So `f("Bruno")` will always return "Bruno likes lasagna".
- This function does not change the state of your program, by adding new objects every time it’s run.

### Predictable functions

Let's now define another function called `g()`, that does not have the same properties as `f()`. First, let's define
a function that does not always return the same output given a particular input:

```{r, eval = F}
g <- function(name){
  food <- sample(c("lasagna", "cassoulet", "feijoada"), 1)
  print(paste0(name, " likes ", food))
}
```

For the same input, "Bruno", this function now produces (potentially) a different output:

```{r, eval = F}
g("Bruno")
[1] "Bruno likes lasagna"
```

```{r, eval = F}
g("Bruno")
[1] "Bruno likes feijoada"
```

And now let's consider function `h()` that modifies the state of the program:

```{r, eval = F}
h <- function(name){
  food <- sample(c("lasagna", "cassoulet", "feijoada"), 1)

  if(exists("food_list")){
    food_list <<- append(food_list, food)
  } else {
    food_list <<- append(list(), food)
  }

  print(paste0(name, " likes ", food))
}
```

This function uses the `<<-` operator. This operator saves definitions that are made inside the body
of functions in the global environment. Before calling this function, run `ls()` again. You should
see the same objects as before, plus the new functions we've defined:

```{r, eval = F}
[1] "a"         "f"          "g"         "h"         "mtcars"   
```

Let's now run `h()` once:

```{r, eval = F}
h("Bruno")
[1] "Bruno likes feijoada"
```

And now `ls()` again:

```{r, eval = F}
[1] "a"         "f"         "food_list" "g"         "h"         "mtcars" 
```

Running `h()` did two things: it printed the message, but also created a variable called "food_list" in the
global environment with the following contents:

```{r, eval = F}
food_list
```

```{r, eval = F}
[[1]]
[1] "feijoada"
```

Let's run `h()` again:

```{r, eval = F}
h("Bruno")
[1] "Bruno likes cassoulet"
```

and let's check the contents of "food_list":


```{r, eval = F}
food_list
```

```{r, eval = F}
[[1]]
[1] "feijoada"

[[2]]
[1] "cassoulet"
```

If you keep running `h()`, this list will continue growing. Let me just say that I hesitated showing you this; this
is because if you didn't know `<<-`, you might find the example above useful. But while useful, it is quite dangerous as well.
Generally, we want to avoid using functions that change the state as much as possible because these function are
unpredictable, especially if randomness is involved. It is much safer to define `h()` like this instead:

```{r, eval = F}
h <- function(name, food_list = list()){

  food <- sample(c("lasagna", "cassoulet", "feijoada"), 1)

  food_list <- append(food_list, food)

  print(paste0(name, " likes ", food))

  food_list
}
```

The difference now is that we made `food_list` the second argument of the function. Also, we defined it as being
optional by writing:

```{r, eval = F}
food_list = list()
```

This means that if we omit this argument, the empty list will get used by default. This avoids the users having
to manually specify it.

We can call it like this:

```{r, eval = F}
food_list <- h("Bruno", food_list) # since food_list is already defined, we don't need to start with an empty list
```

```{r, eval = F}
[1] "Bruno likes feijoada"
```

We save the output back to `food_list`. Let's now check its contents:

```{r, eval = F}
food_list
```

```{r, eval = F}
[[1]]
[1] "feijoada"

[[2]]
[1] "cassoulet"

[[3]]
[1] "feijoada"
```

The only thing that we need now to deal with is the fact that the food gets chosen randomly. I'm going to show you the
simple way of dealing with this, but later in this chapter we are going to use the `{withr}` package for situations
like this. Let's redefine `h()` one last time:

```{r, eval = F}
h <- function(name, food_list = list(), seed = 123){

  # We set the seed, making sure that we get the same selection of food for a given seed
  set.seed(seed)
  food <- sample(c("lasagna", "cassoulet", "feijoada"), 1)

  # We now need to unset the seed, because if we don't, guess what, the seed will stay set for the whole session!
  set.seed(NULL)

  food_list <- append(food_list, food)

  print(paste0(name, " likes ", food))

  food_list
}
```

Let's now call `h()` several times with its default arguments:

```{r, eval = F}
h("Bruno")
```

```{r, eval = F}
[1] "Bruno likes feijoada"
[[1]]
[1] "feijoada"
```

```{r, eval = F}
h("Bruno")
```

```{r, eval = F}
[1] "Bruno likes feijoada"
[[1]]
[1] "feijoada"
```

```{r, eval = F}
h("Bruno")
```

```{r, eval = F}
[1] "Bruno likes feijoada"
[[1]]
[1] "feijoada"
```

As you can see, every time this function runs, it now produces the same result. Users can change the seed to have this function produce, consistently,
another result.

### Referentially transparent and pure functions

A referentially transparent function is a function that does not use any variable that is not also one of its inputs. For example, the following function:

```{r, eval = F}
bad <- function(x){
  x + y
}
```

is not referentially transparent, because `y` is not one of the functions inputs. What happens if you run `bad()` is that `bad()` needs to look for `y`. 
Because `y` is not one of its inputs, `bad()` then looks for it in the global environment. If `y` is defined there, it then gets used. Defining and using
such functions must be avoided at all costs, because these functions are unpredictable. For example:


```{r, eval = F}
y <- 10
bad <- function(x){
  x + y
}

bad(5)
```

This will return `15`. But if `y <- 45` then `bad(5)` would this time around return `50`. It is much safer, and easier to make `y` an explicit input of 
the function instead of having to keep track of `y`’s value:

```{r, eval = F}
good <- function(x, y){
  x + y
}
```

`good()` is a referentially transparent function; it is much safer than `bad()`. `good()` is also a pure function, because it’s a function that does not interact
in any way with the global environment. It does not write anything to the global environment, nor requires anything from the global environment. Function `h()`
from the previous section was not pure, because it created an object and wrote it to the global environment (the `food_list` object). Turns out that pure 
functions are thus necesarrily referentially transparent.

So the first lesson in your functional programming journey that you have to remember is to only use pure functions.

## Writing good functions
### Functions are first class objects

In a functional programming language, functions are first class objects. Contrary to what the name implies, this means that functions, especially the ones you define
yourself, are nothing special. A function is an object like any other, and can thus be manipulated as such. Think of anything that you can do with any object in R,
and you can do the same thing with a function. For example, let’s consider the `+()` function. It takes two numeric objects and retuns their sum:

```{r}
1 + 5.3

# or alternatively: `+`(1, 5.3)
```

You can replace the numbers by functions that return numbers:

```{r}
sqrt(1) + log(5.3)
```

It’s also possible to define a function that explicitely takes another function as an input:

```{r}
h <- function(number, f){
  f(number)
}
```

You can call then use `h()` as a wrapper for `f()`:

```{r}
h(4, sqrt)

h(10, log10)
```

If you don’t know how many arguments `f()`, the function you’re wrapping, has, you can use the `...`:

```{r}
h <- function(number, f, ...){
  f(number, ...)
}
```

`...` are simply a placeholder for any potential additional argument that `f()` might have:

```{r}
h(c(1, 2, NA, 3), mean, na.rm = TRUE)

h(c(1, 2, NA, 3), mean, na.rm = FALSE)
```

`na.rm` is an argument of `mean()`. As the developer of `h()`, I don’t necessarily know what `f()` might be, or maybe I know `f()` and know all its
arguments, but don’t want to have to rewrite them all to make them arguments of `h()`, so I can use `...` instead. If you want to learn more about `...`, type 
`?dots` in an R console.

## Optional arguments

It is possible to make function arguments optional, by using `NULL`. For example:

```{r}
g <- function(x, y = NULL){
  if(is.null(y)){
    print("optional argument y is NULL")
    x
  } else {
    if(y == 5) print("y is present"); x+y
  }
}
```

Calling `g(10)` prints the message "Optional argument y is NULL", and returns 10. Calling `g(10, 5)` however, prints "y is present" and returns 15.

## Lists: a powerful data-structure




