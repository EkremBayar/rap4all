# Collaborating with Github

As already mentioned several times, there are two ways of collaborating with Git (and Github):
either as a team, or either as an external dev (external, as in, not part of the development team)
who wishes to provide some code to a project (this only works for repositories that are public).

## Collaborating as a team using *trunk-based development*

Remember the issue we opened and assigned to Bruno? Bruno will now solve this issue by adding a
Readme. This will be also the opportunity to introduce trunk-based development. The idea of
trunk-based development is simple; team members should work on separate branches to add features or
fix bugs, and then merge their branch to the "trunk" (in our case the *master* branch) to add their
changes back to the main code-base. And this process should happen quickly, ideally every day, or
as soon as some code is ready. This way, if conflicts arise, they can be dealt with quickly. This
also makes code review much easier, because the reviewer only needs to review little bits of code
at a time. The alternative would be for each team member to work on his or her own branch for days,
or even weeks. Once the branches get merged to the trunk, the conflicts that will need to be solved
and reviewing all these changes would be very painful. To avoid this, it is best to merge every day,
or each time a piece of code is added, and, **very importantly**, this code does not break the whole
project (we will be using unit tests for this later).

So in summary: to avoid a lot of pain later by merging branches that moved away too much from the
trunk, we will create branches, add our code, and merge them to the trunk as soon as possible. *As
soon as possible* can mean several things, but usually this means as soon as the feature was added,
the bug fixed, or as soon as we added some code that does not break the whole project, even if the
feature we wanted to add is not done yet. The philosophy is that if merging fails, it should fail
as early as possible. Early failures are easy to deal with.

So, back to our issue. First, Bruno needs to clone the repository:

```
git clone git@github.com:rap4all/housing.git
```

Because Bruno was added as a collaborator, Bruno can work on the repository just like the author.

Bruno will now create a new branch by using the `git checkout` command with the 
`-b` flag:

```
bruno@computer ➤ git checkout -b "add_readme"
```

The project automatically switches to the new branch:

```
Switched to a new branch 'add_readme'
```

We can also run `git status` to double-check:

```
bruno@computer ➤ git status
```

```
On branch add_readme
nothing to commit, working tree clean
```

Let's add a file called `README.md` and add the following in it:

````{verbatim}
# Housing data for Luxembourg

These scripts for the R programming language download nominal housing prices
from the *Observatoire de l'Habitat* and tidy them up into a flat data frame.

- save_data.R: downloads, cleans, and creates data frames from the data
- analysis.R: creates plots of the data
````

Let's save this and run `git status` to see what happened:

```
bruno@computer ➤ git status
```

Git tells us that the `README.md` file is not being tracked:

```
On branch add_readme
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        README.md

nothing added to commit but untracked files present (use "git add" to track)
```

So next we are going to track it, and push the changes. Also, we are going to use a neat trick when
pushing: we are going to use the commit message to state the issue was fixed, which will automatically
close the issue for us:

```
bruno@computer ➤ git add .
bruno@computer ➤ git commit -am "fixed #1"
```

`#1` refers to the number of the issue. Because it's the first issue, it can be simply be referred
to as `#1`. Bruno will now push:

```
bruno@computer ➤ git push origin add_readme
```

As you can see from the command above, Bruno pushes to "add_readme", not "master". If he tried to push
to "master" a message saying that "master" is up-to-date would get printed. Let's see the output of
pushing to "add_readme":

```
Enumerating objects: 4, done.
Counting objects: 100% (4/4), done.
Delta compression using up to 12 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 501 bytes | 501.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
remote: 
remote: Create a pull request for 'add_readme' on GitHub by visiting:
remote:      https://github.com/rap4all/housing/pull/new/add_readme
remote: 
To github.com:rap4all/housing.git
 * [new branch]      add_readme -> add_readme
```

Git tells us that we now need to create a pull request. What is that? Well, if we want to merge
our brunch back to the trunk, we need to do so by using a pull request. Let's see what
Bruno sees on Github:

![Bruno sees that the "add_readme" branch has been recently updated](images/github_add_readme_recent_push.png)

Bruno can now decide to continue working on this branch, or, since the purpose of this branch was only
to add the readme file, decide instead to do a pull request. By clicking on the "Compare & pull request"
button Bruno now sees this:

![This screen makes it easy to see what changed](images/github_pull_request.png)

Bruno can leave a comment, see what changed (in this case, a single file was added) and most importantly, add
a reviewer if needed:

![Let boss decide if this is good enough](images/github_add_reviewer.png)

This is what Bruno sees now:

![Github tells us that this branch can safely be merged](images/github_reviewer_requested.png)

Bruno requested the review, but Github tells us that the brach can safely be merged. This is
because we added a file and did not touch anything else, and also because the owner of the
repository was asleep while Bruno was working, so there was no opportunity for conflicts to arise.

Let's see what the owner now sees. The owner should have gotten a notification to review the pull request:

![The owner was notified to review the pull request](images/github_reviewer_notified.png)

By clicking on the notification, the owner gets taken to this view:

![Time to review the pull request](images/github_review.png)

Here, the reviewer can check the commit, the files that were changed, and see if there any
conflicts between this code and the code base on the master (or trunk) branch. Github also tells us
two interesting things: the owner can add a rule that states that any pull request must be
approved, and also that continuous integration has not been set up (we are going to see what this means in the second
part of this book).

Let's go ahead and add a rule that each pull request has to be approved. By clicking on "Add rule",
the following screen appears:

![Choose how to protect the master branch](images/github_rules.png)

By clicking the first option, more options appear:

![Reviews are now required](images/github_rules_2.png)

By choosing these options, the owner can basically enforce trunk based development (well,
collaborators still have to submit pull request frequently enough though, because if they don't, we
can be in a situation where merging can be very difficult).

Let's choose one last option: by scrolling down, it's possible to select the option "Do not allow
bypassing the above settings". This makes sure that even administrations (the owners of the
project) must abide by the same rules.

Let's go back to the pull request. We can see now that the review is required:

![Time to review](images/github_review_required.png)

So now the owner actually has to go and see the files that were changed:

![Check the code, and add comments if needed](images/github_add_your_review.png)

It's possible to add comments to single lines, if needed:

![It's possible to add comments to lines](images/github_review_comments.png)

By clicking on the plus sign, a box appears and it's possible to leave a comment. In this case, everything is fine,
so the owner is going to click on the "Viewed" button:

![Good job!](images/github_file_viewed.png)

Then, by clicking on "Review changes", it's possible to either add a general comment, approve the pull request, or 
request changes that must be addressed before merging. Let's go ahead and approve:

![Nothing to complain about](images/github_approve.png)

By submitting the review, the reviewer is taken back to the issue:

![We're done, we can merge the pull request](images/github_changes_approved.png)

The reviewer can now merge the pull request by clicking on the "Merge pull request" button. Github even suggests we 
deleted the branch, which served its purpose:

![Let's get rid of this branch](images/github_pull_request_done.png)

Let's delete it (it's always possible to restore it).
