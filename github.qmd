# Collaborating with Github

As already mentioned several times, there are two ways of collaborating with Git (and Github):
either as a team, or either as an external dev (external, as in, not part of the development team)
who wishes to provide some code to a project (this only works for repositories that are public).

## Collaborating as a team using *trunk-based development*

Remember the issue we opened and assigned to Bruno? Bruno will now solve this issue by adding a
Readme. This will be also the opportunity to introduce trunk-based development. The idea of
trunk-based development is simple; team members should work on separate branches to add features or
fix bugs, and then merge their branch to the "trunk" (in our case the *master* branch) to add their
changes back to the main code-base. And this process should happen quickly, ideally every day, or
as soon as some code is ready. This way, if conflicts arise, they can be dealt with quickly. This
also makes code review much easier, because the reviewer only needs to review little bits of code
at a time. The alternative would be for each team member to work on his or her own branch for days,
or even weeks. Once the branches get merged to the trunk, the conflicts that will need to be solved
and reviewing all these changes would be very painful. To avoid this, it is best to merge every day,
or each time a piece of code is added, and, **very importantly**, this code does not break the whole
project (we will be using unit tests for this later).

So in summary: to avoid a lot of pain later by merging branches that moved away too much from the
trunk, we will create branches, add our code, and merge them to the trunk as soon as possible. *As
soon as possible* can mean several things, but usually this means as soon as the feature was added,
the bug fixed, or as soon as we added some code that does not break the whole project, even if the
feature we wanted to add is not done yet. The philosophy is that if merging fails, it should fail
as early as possible. Early failures are easy to deal with.

So, back to our issue. First, Bruno needs to clone the repository:

```
git clone git@github.com:rap4all/housing.git
```

Because Bruno was added as a collaborator, Bruno can work on the repository just like the author.

Bruno will now create a new branch by using the `git checkout` command with the 
`-b` flag:

```
bruno@computer ➤ git checkout -b "add_readme"
```

The project automatically switches to the new branch:

```
Switched to a new branch 'add_readme'
```

We can also run `git status` to double-check:

```
bruno@computer ➤ git status
```

```
On branch add_readme
nothing to commit, working tree clean
```

Let's add a file called `README.md` and add the following in it:

````
# Housing data for Luxembourg

These scripts for the R programming language download nominal housing prices
from the *Observatoire de l'Habitat* and tidy them up into a flat data frame.

- save_data.R: downloads, cleans, and creates data frames from the data
- analysis.R: creates plots of the data
````

Let's save this and run `git status` to see what happened:

```
bruno@computer ➤ git status
```

Git tells us that the `README.md` file is not being tracked:

```
On branch add_readme
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        README.md

nothing added to commit but untracked files present (use "git add" to track)
```

So next we are going to track it, and push the changes. Also, we are going to use a neat trick when
pushing: we are going to use the commit message to state the issue was fixed, which will automatically
close the issue for us:

```
bruno@computer ➤ git add .
bruno@computer ➤ git commit -am "fixed #1"
```

`#1` refers to the number of the issue. Because it's the first issue, it can be simply be referred
to as `#1`. Bruno will now push:

```
bruno@computer ➤ git push origin add_readme
```

As you can see from the command above, Bruno pushes to "add_readme", not "master". If he tried to push
to "master" a message saying that "master" is up-to-date would get printed. Let's see the output of
pushing to "add_readme":

```
Enumerating objects: 4, done.
Counting objects: 100% (4/4), done.
Delta compression using up to 12 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 501 bytes | 501.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
remote: 
remote: Create a pull request for 'add_readme' on GitHub by visiting:
remote:      https://github.com/rap4all/housing/pull/new/add_readme
remote: 
To github.com:rap4all/housing.git
 * [new branch]      add_readme -> add_readme
```

Git tells us that we now need to create a pull request. What is that? Well, if we want to merge
our brunch back to the trunk, we need to do so by using a pull request. Let's see what
Bruno sees on Github:

![Bruno sees that the "add_readme" branch has been recently updated](images/github_add_readme_recent_push.png)

Bruno can now decide to continue working on this branch, or, since the purpose of this branch was only
to add the readme file, decide instead to do a pull request. By clicking on the "Compare & pull request"
button Bruno now sees this:

![This screen makes it easy to see what changed](images/github_pull_request.png)

Bruno can leave a comment, see what changed (in this case, a single file was added) and most importantly, add
a reviewer if needed:

![Let boss decide if this is good enough](images/github_add_reviewer.png)

This is what Bruno sees now:

![Github tells us that this branch can safely be merged](images/github_reviewer_requested.png)

Bruno requested the review, but Github tells us that the brach can safely be merged. This is
because we added a file and did not touch anything else, and also because the owner of the
repository was asleep while Bruno was working, so there was no opportunity for conflicts to arise.

Let's see what the owner now sees. The owner should have gotten a notification to review the pull request:

![The owner was notified to review the pull request](images/github_reviewer_notified.png)

By clicking on the notification, the owner gets taken to this view:

![Time to review the pull request](images/github_review.png)

Here, the reviewer can check the commit, the files that were changed, and see if there any
conflicts between this code and the code base on the master (or trunk) branch. Github also tells us
two interesting things: the owner can add a rule that states that any pull request must be
approved, and also that continuous integration has not been set up (we are going to see what this means in the second
part of this book).

Let's go ahead and add a rule that each pull request has to be approved. By clicking on "Add rule",
the following screen appears:

![Choose how to protect the master branch](images/github_rules.png)

By clicking the first option, more options appear:

![Reviews are now required](images/github_rules_2.png)

By choosing these options, the owner can basically enforce trunk based development (well,
collaborators still have to submit pull request frequently enough though, because if they don't, we
can be in a situation where merging can be very difficult).

Let's choose one last option: by scrolling down, it's possible to select the option "Do not allow
bypassing the above settings". This makes sure that even administrations (the owners of the
project) must abide by the same rules.

Let's go back to the pull request. We can see now that the review is required:

![Time to review](images/github_review_required.png)

So now the owner actually has to go and see the files that were changed:

![Check the code, and add comments if needed](images/github_add_your_review.png)

It's possible to add comments to single lines, if needed:

![It's possible to add comments to lines](images/github_review_comments.png)

By clicking on the plus sign, a box appears and it's possible to leave a comment. In this case, everything is fine,
so the owner is going to click on the "Viewed" button:

![Good job!](images/github_file_viewed.png)

Then, by clicking on "Review changes", it's possible to either add a general comment, approve the pull request, or 
request changes that must be addressed before merging. Let's go ahead and approve:

![Nothing to complain about](images/github_approve.png)

By submitting the review, the reviewer is taken back to the issue:

![We're done, we can merge the pull request](images/github_changes_approved.png)

The reviewer can now merge the pull request by clicking on the "Merge pull request" button. Github even suggests we 
deleted the branch, which served its purpose:

![Let's get rid of this branch](images/github_pull_request_done.png)

Let's delete it (it's always possible to restore it).

## Handling conflicts

As mentioned in the previous chapter, Git makes it easy to handle conflicts. Well, let's be clear; it can be very tricky
sometimes to resolve conflicts. But you should know that when solving a conflict with Git is difficult, this usually means 
that it would be impossible to do any other way, and would inevitably result in someone having to reconcile the files
by hand.

Let's see what happens when a conflict arises. In this scenario, both Bruno and the project owner will create a branch, and
edit the same file. Perhaps they talked over the phone and decided to add a feature, or correct a bug. Perhaps they decided
that it wasn't worth it to open an issue on Github and assign someone to do it. After all, they discussed this on the phone
and decided that Bruno should do it. Or was it the owner who needed to solve the issue? No one remembers now. Either way,
they both did, and what follows is what happens in that scenario.

First, Bruno needs to switch back to the master branch on his computer:

```
bruno@computer ➤ git checkout master
```

```
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
  (use "git pull" to update your local branch)
```

Git tells us to update the code on our computer by running `git pull`. We use `git push` to upload code to Github, and
use `git pull` to download code from Github. Let's run it and see what happens:

```
bruno@computer ➤ git pull
```

```
Updating b7f82ee..c774ebf
Fast-forward
 README.md | 7 +++++++
 1 file changed, 7 insertions(+)
 create mode 100644 README.md
```

The owner of the project (called `owner`, remember?) can do the same and will see the same. Now, Bruno creates a new branch
to work on the new feature:

```
bruno@computer ➤ git checkout -b add_cool_feature
```

And the project owner also create a new branch:

```
owner@localhost ➤ git checkout -b add_nice_feature
```

They now edit the same file, `analysis.R`. Bruno added this function:

```{r, eval = F}
make_plot <- function(country_level_data,
                      commune_level_data,
                      commune){

  filtered_data <- commune_level_data %>%
    filter(locality == commune)

  data_to_plot <- bind_rows(
    country_level_data,
    filtered_data
  )

  ggplot(data_to_plot) +
    geom_line(aes(y = pl_m2,
                  x = year,
                  group = locality,
                  colour = locality))
}

```

This way, Bruno could delete the repeating code and create plots like this:


```{r, eval = F}
lux_plot <- make_plot(country_level_data,
                      commune_level_data,
                      communes[1])


# Esch sur Alzette

esch_plot <- make_plot(country_level_data,
                       commune_level_data,
                       communes[2])

# and so on...
```

The end effect is the same, but by using this function, the code is now shorter, and clearer. Also, if someone
wants to change, say, the theme of the plot, now this only needs to be changed in one place and not for each 
commune. Now, what did the owner change? The owner started by removing the line that loaded the `{purrr}`
package, as no function from the package was used in the script, and then also changed every `%>%`
to `|>`. It seems that much more than just who would make the changes got lost in translation... Anyways,
both now push their changes to their respective branches. This is Bruno:

```
bruno@computer ➤ git add .
bruno@computer ➤ git commit -am "make_plot() for plotting"
bruno@computer ➤ git push origin add_cool_feature
```

```
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 12 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 647 bytes | 647.00 KiB/s, done.
Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
remote: 
remote: Create a pull request for 'add_cool_feature' on GitHub by visiting:
remote:      https://github.com/rap4all/housing/pull/new/add_cool_feature
remote: 
To github.com:rap4all/housing.git
 * [new branch]      add_cool_feature -> add_cool_feature
```

and this is the owner:

```
owner@localhost ➤ git add .
owner@localhost ➤ git commit -am "cleanup"
owner@localhost ➤ git push origin add_sweet_feature
```

```
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 4 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 449 bytes | 449.00 KiB/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
remote: 
remote: Create a pull request for 'add_sweet_feature' on GitHub by visiting:
remote:      https://github.com/rap4all/housing/pull/new/add_sweet_feature
remote: 
To github.com:rap4all/housing.git
 * [new branch]      add_sweet_feature -> add_sweet_feature
```
