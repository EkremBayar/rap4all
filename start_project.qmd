# Getting started with your project

In order to build a reproducible pipeline, we will be working together on a project.
The project itself will be quite simple and will simply consist is getting some data
"trapped" inside a Microsoft Excel Workbook into a data frame, and then creating
a plot. The point is not making this plot, engineering the project in such a way 
that it is:

- Documented;
- Tested;
- Reproducible.

We will start our project like someone with time constraints does, and
see how we can reach our goal of having a nice reproducible project as painlessly as
possible. There is only one catch; to make the whole process as easy as possible, we
will start our analysis by writing a Quarto file, not a standard R script.

*What Sébastien said on the matter:* 

*There seems to be two way of presenting such a workflow:

What does the complete project looks like at the end and what tools do I need?
How do I start working on it?*

*This questions should get answered in the intro?*

*Refer to [https://github.com/b-rodrigues/rap4all/issues/1#issuecomment-1327627267](https://github.com/b-rodrigues/rap4all/issues/1#issuecomment-1327627267)*

## Literate programming

In literate programming, we mix code and prose together, in a way that makes it easy for
both non-technical users and programmers to understand what is going on. Scripts written this
way are also very easy to compile, or render, into a variety of document formats like `html` 
and `docx`. R supports several ways of doing literate programming: Sweave, knitr and Quarto.

Sweave was the first tool available to R (and S) users, and allowed the mixing of R and LaTeX
code to create a document. Sweave as was authored by Friedrich Leisch in 2002 and described
in his 2002 paper (@leisch2002). As Leisch argues, *the traditional way of writing a report as 
part of a statistical data naalysis project uses two separate steps*: running the analysis
using some software, and then copy and pasting the results into a word processing tool.
The problem with this approach is that much time is wasted copy and pasting things, so 
experimenting with different layouts is very time consuming. Copy and paste mistakes will
also happen (it’s not a question of if, but when) and updating reports (for example, when
new data comes in) means that someone will have, again, to copy and paste the updated
results into a new document.

Sweave provided a way to embed the analysis in the document itself, in this case a LATEX
source file, and R code was executed whenever the document was compiled. This gave statisticians
considerable time savings when it was time to update a report (or to experiment with different
layouts).

The snippet below shows the example from Leisch’s paper:

```
\documentclass[a4paper]{article}

\begin{document}

In this example we embed parts of the examples from the
\texttt{kruskal.test} help page into a LaTeX document:

<<>>=
data (airquality)
kruskal.test(Ozone ~ Month, data = airquality)
@

which shows that the location parameter of the Ozone
distribution varies significantly from month to month.
Finally we include a boxplot of the data:

\begin{center}
<<fig=TRUE,echo=FALSE>>=
boxplot(Ozone ~ Month, data = airquality)
@
\end{center}

\end{document}
```

Even if you’ve never seen a LATEX source file, you should be able to figure out what’s going on. The first
line states what type document of document we’re writing. Then comes `\begin{document}` which tells
the compiler where the document starts. Then comes the content. You can see that it’s a mixture of plain
English with R code defined inside a chunk starting with `<<>>=` and ending with `@`. Finally, the
documents ends with `\end{document}`. Getting a humand readable PDF from this source is a two-step process:
first this source get’s converted into a `.tex` file and then this `.tex` file into a PDF. Sweave is 
included with every R installation since version 1.5.0, and still works to this day. For example,
we can test that our Sweave installation works just fine by compiling the example above. This
is what the final output looks like:

![More than 20 years later, the output is still the same](images/hello_sweave.PNG)

Let us just state that the fact that it is still possible to compile this example more than 20
years later is an incredible testament to how mature and stable this software is (both R, Sweave,
and LATEX). But as impressive as this is, LATEX has a steep learning curve, and Leisch even
advocated the use of the Emacs text editor to edit Sweave files, which also has a very steep
learning curve (but this is entirely optional; for example we edited and compiled the example on
the Rstudio IDE).

The following generation of literate programming tools was provided by a package called `{knitr}`
in 2012.
From the perspective of the user, the biggest change from Sweave is that `{knitr}` is able to use
many different formats for the source files. The one that became very likely the most widely used
format is a flavour of the Markdown markup language, R Markdown (Rmd). But `{knitr}` can also run
code chunks from other languages, such as Python, Perl, Awk, Haskell, bash and more (@xie2014).
Since version 1.18, `{knitr}` uses the `{reticulate}` package to provide a Python engine for 
the Rmd format. To illustrate the Rmd format, let’s rewrite the example from
Leisch’s Sweave paper into it:

````{verbatim}
---
output: pdf_document
---

In this example we embed parts of the examples from the
\texttt{kruskal.test} help page into a LaTeX document:

```{r}
data (airquality)
kruskal.test(Ozone ~ Month, data = airquality)
```

which shows that the location parameter of the Ozone
distribution varies significantly from month to month.
Finally we include a boxplot of the data:

```{r, echo = FALSE}
boxplot(Ozone ~ Month, data = airquality)
```


````

This is what the output looks like:


![It’s very close to the Sweave output](images/hello_rmd.PNG)

Just like in a Sweave document, an Rmd source file also had a header in which authors can define
a number of options. Here we only specified that we wanted a pdf document as an output file.
We then copy and pasted the contents from the Sweave source, but changed the chunk delimiters from
 `<<>>=` and `@` to ` \x60\x60\x60{r} ` to start an R chunk and ` \x60\x60\x60 ` to end it.
Remember; we need to specify the engine in the chunk because `{knitr}` supports many engines. For
example, it is possible to run a bash command by adding this chunk to the source:

````{verbatim}
---
output: pdf_document
---

In this example we embed parts of the examples from the
\texttt{kruskal.test} help page into a LaTeX document:

```{r}
data (airquality)
kruskal.test(Ozone ~ Month, data = airquality)
```

which shows that the location parameter of the Ozone
distribution varies significantly from month to month.
Finally we include a boxplot of the data:

```{r, echo = FALSE}
boxplot(Ozone ~ Month, data = airquality)
```

```{bash}
pwd
```

````

(bash’s `pwd` command shows the current working directory). You may have noticed that we also keep
two LaTeX commands in the source Rmd, `\texttt{}` and `LaTeX`. This is because Rmd files get
first converted into `LaTeX` files and then into a PDF. If you’re using RStudio, this document
can be compiled by clicking a button or using a keyboard shortcut, but you can also use the
`rmarkdown::render()` function. This function does two things transparently: it first converts the
Rmd file into a source LaTeX file, and then converts it into a PDF. It is of course possible to
convert the document to a Word document as well however, LaTeX commands will be ignored. Html is
another widely used output format.

You should know that `{knitr}` makes it possible to author many, many different types of documents.
It is possible to write books, blog, package documentation (and even entire packages, as we 
shall see later in this book), Powerpoint slides... It is extremely powerful because we can use
the same general R Markdown knowledge to build many different outputs:

![One format to rule them all](images/rmd_to_many.PNG)

Finally, the latest in literate programming for R is a new tool developed by Posit, called Quarto.
If you’re an R user and already know `{knitr}` and the Rmd format, you should be able to
immediately use Quarto. So what’s the difference? In practice and for R users not much. There are
many things that Quarto is able to do out of the box that you can’t, without extensions, do with
`{knitr}`. Quarto has some nice defaults; in fact this book is written in Quarto instead of `{knitr}`
because the default Quarto output looks nicer than the default `{knitr}` output. However, there
may even be things that Quarto can’t do at all (at least for now) when compared to `{knitr}`. So
why bother switching? Well, Quarto provides sane defaults and some nice features out of the box,
and the cost of switching from the Rmd format to Quarto’s Qmd format is basically 0. Also, and this
is probably the biggest reason to use Quarto, is that Quarto is not tied to R. Quarto is actually a
standalone tool that needs to be installed alongside your R installation, and works completely
independently. In fact, you can use Quarto without having R installed at all, as Quarto, just like
`{knitr}` supports many engines. This means that if you’re primarily using Python, you can author
documents with Quarto. Quarto also supports the Julia programming language and Observable JS,
making it possible to include interactive visualisations into an Html document. Let’s take a look
at how the example from Leisch’s paper look as a Qmd file:

````{verbatim}
---
output: pdf
---

In this example we embed parts of the examples from the
\texttt{kruskal.test} help page into a LaTeX document:

```{r}
data (airquality)
kruskal.test(Ozone ~ Month, data = airquality)
```

which shows that the location parameter of the Ozone
distribution varies significantly from month to month.
Finally we include a boxplot of the data:

```{r, echo = FALSE}
boxplot(Ozone ~ Month, data = airquality)
```

````

(I’ve omitted the bash chunk from before, not because Quarto does not support it, but to keep close
to the original example from the paper.)

As you can see, it’s exactly the same as the Rmd file from before. The only difference is in the
header. In the Rmd file we specified the output format as:


````
---
output: pdf_document
---
````

whereas in the Qmd file we changed it to:

````
---
output: pdf
---
````

While Quarto is the latest option in literate programming, it is quite recent, and as such, we feel
it might be better to stick with `{knitr}` and the Rmd format for now, so that’s what we’re going
to use going forward. However, we won’t be focused on anything really `{knitr}` or Rmd specific, so
should you want to use Quarto instead, you should be able to follow along without any problems at
all, since the Rmd and Qmd formats have so much overlap (but whenever there would be major
differences between the two formats, we will highlight them).

## `{knitr}` basics

This section will be a very small intro. We are going to teach you just enough to get started, and
we are going to focus on the Rmd format. There are many resources out there that you can use if you
want to dig deeper, for instance the [R Markdown website](https://rmarkdown.rstudio.com/lesson-1.html) 
from Posit, or the [R Markdown: The Definitive Guide](https://bookdown.org/yihui/rmarkdown/) eBook.
We will also not assume that you are using the RStudio IDE and give you instead the lower
level commands to render documents. If you use RStudio and want to know how to use it effectively to author
Rmd documents, you should take a look at [Quick Tour](https://rmarkdown.rstudio.com/authoring_quick_tour.html)
page. In fact, this section will basically focus on the same topics, but without focusing on how to use 
RStudio.

### Set up

The first step is to install the `{knitr}` and the `{rmarkdown}` packages. Simple type:

```{r, eval = F}
install.packages("rmarkdown")
```

in an R console. Since `{knitr}` is required to install `{rmarkdown}`, this gets installed
automatically. If you want to compile PDF documents, you should also have a working LaTeX
distribution. You can skip this next part if you’re only interested in generating PDF and Word
files. For what follows, we will only be rendering Html documents, so no need to install LaTeX
(by the way, you do not need a working Word installation to compile document to the docx format).
However, if you already have a working LaTeX installation, you shouldn’t have to do anything
else to generate PDF documents. If you don’t have a working LaTeX distribution, then Yihui Xie,
the creator of `{knitr}` created an R package called `{tinytex}` that makes it extremely easy to
install a LaTeX distribution. In fact, this is the way we recommend to install LaTeX even if
you’re not an R user (it is possible to use the tinytex distribution without R; it’s just that
the `{tinytex}` R package provides many functions that makes installing and maintaining it very easy). 
Simply run these commands in an R console to get started:

```{r, eval = F}
install.packages("tinytex")
tinytex::install_tinytex()
```

and that’s it! If you need to install specific LaTeX packages, then refer to the **Maintenance** section
on [tinytex’s](https://yihui.org/tinytex/#maintenance) website. For example, to compile the example from Leisch’s
article on Sweave discussed previously, we had to install the `grfext` LaTeX package (as explained by the error
output in the console when I tried compiling). So, we simply needed to run the following command to get it:

```{r, eval = F}
tlmgr_install("grfext")
```

After you’ve installed `{knitr}`, `{rmarkdown}` and, optionally, `{tinytex}`, simply try to compile the following
document:

````{verbatim}
---
output: html_document
---

# Document title

## Section title

### Subsection title

This is **bold** text. This is *text in italics*.

My favourite programming language for statistics is ~~SAS~~ R.

````

save this document into a file called `rmd_intro.rmd` using you’re favourite text editor. Then render it into
an Html file by running the following command in the R console:

```{r, eval = F}
rmarkdown::render("path/to/rmd_test.rmd")
```

This should create a file called `rmd_test.html`; open it with your web browser and you should see the following:

![It’s very close to the Sweave output](images/rmd_test.PNG)

Congratulations, you just *knitted* your first Rmd document!

### Markdown ultrabasics

R Markdown is a flavour of Markdown, which means that you should know some Markdown to really take full advantage of 
R Markdown. The document from before should have already shown you some basics, title, sections and subsections
all start with a `#` and the depth level is determined by the number of `#`s. For bold text, simply put the words in
between `**` and for italics use only one `*`. If you want ***bold and italics***, use `***`. The original
designer of Markdown did not think that underlining text was important, so there is no *easy* way of doing it 
unfortunately. For this, you need to use a somewhat hidden feature; without going into too much technical details,
the program that converts Rmd files to the final output format is called Pandoc, and it’s possible to use 
Pandoc instead for this:

````{verbatim}
[This is some underlined text in a R Markdown document]{.underline}
````

This will underline the text between square brackets.[^1]

[^1]: https://stackoverflow.com/a/68690065/1298051

The next step is actually to mix code and prose. As you’ve seen from Leisch’s canonical example, this is quite easily
achieved by using R code chunks. The R Markdown example below shows various code chunks alongside some options.
For example, a code chunk that use the `echo = FALSE` option will not appear (but the output of the computation
will):

````{verbatim}
---
title: "Document title"
output: html_document
date: "2023-01-28"
---

# R code chunks

This below is an R code chunk:


```{r}
data(mtcars)

plot(mtcars)
```

The code chunk above will appear in the final output. The code chunk below will be hidden:

```{r, echo = FALSE}
data(iris)

plot(iris)
```

This next code chunk will not be evaluated:

```{r, eval = FALSE}
data(titanic)

str(titanic)
```

The last one runs, but code and output from the code is not shown in the final document.
This is useful for loading libraries and hiding startup messages:

```{r, include = FALSE}
library(dplyr)
```

````

If you use RStudio and create a new R Markdown file from the menu, a new R Markdown file is generated
for you to fill out. The first R chunk is this one:

````{verbatim}
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
````

This is an R chunk, named `setup` and with the option `include = FALSE`. Naming chunks is optional, but 
we are going to make use of this later on. What this chunk runs is one line of code that defines a global
options to show all chunks by default (which is the default behaviour). You can change `TRUE` to `FALSE`
if you want to hide every code chunk instead (if you’re using Quarto, global options are set
[differently](https://quarto.org/docs/computations/execution-options.html)).

Something else you might have noticed in the previous example, is that we’ve added some more content in the header:

````{verbatim}
---
title: "Document title"
output: html_document
date: "2023-01-28"
---
````

There are several other options available that you can define in the header. Later on, when we’ll be building our 
project together, we will provide some more options (like having a table of contents).

The finish this part on code chunks, you should know about inline code chunks. Take a look at following example:

````{verbatim}
---
title: "Document title"
output: html_document
date: "2023-01-28"
---

# R code chunks


```{r, echo = FALSE}
data(iris)
```

The iris dataset has `r nrow(iris)` rows.
````

This quite useful, as it allows to parametrize sentences and paragraphs, and thus avoids needing to copy and paste 
(and we will go quite far into how to avoid copy and pasting, thanks to parametrized reports, discussed in the
next section).

To finish this crash course, you should know that to use footnotes you need to write the following:


````{verbatim}
This sentence has a footnote.[^1]

[^1]: This is the footnote.
````

and that you can write LaTeX formulas as well. For example, add the following into the the
example from before and render either a PDF or a html document (don’t put the LaTeX formula
belowe inside a chunk. This doesn’t work for Word output because Word does not support LaTeX
equations):

````{verbatim}
\begin{align*}
S(\omega) 
&= \frac{\alpha g^2}{\omega^5} e^{[ -0.74\bigl\{\frac{\omega U_\omega 19.5}{g}\bigr\}^{\!-4}\,]} \\
&= \frac{\alpha g^2}{\omega^5} \exp\Bigl[ -0.74\Bigl\{\frac{\omega U_\omega 19.5}{g}\Bigr\}^{\!-4}\,\Bigr] 
\end{align*}
````

## Keep it DRY

Whatever you’re doing, you should keep it DRY - DRY stands for *don’t repeat yourself*. Repeating yourself by,
say, copy and pasting, leads to errors and makes reading and understanding your code more difficult.
This can be avoided by using functions, as we discussed in the previous chapter, but what if you need to write
a document that has the following structure:

- A title
- A section
- A table inside this section
- Another section
- Another table inside this section
- Yet another section
- Yet another table inside this section

Is there a way to automate the creation of such a document by taking advantage of the repeating structure? Of course
there is. The question is not, *is it possible to do X?*, but *how to do ?*.

### Generating R Markdown code from code

The example below is a fully working minimal example of this. Copy it inside a document titled something like
`rmd_templating.Rmd` and render it. You will see that the output contains more sections that defined in the source.
This is because we use templating at the end:

````{verbatim}
---
title: "Templating"
output: html_document
date: "2023-01-27"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## A function that creates tables

```{r}
create_table <- function(dataset, var){
  table(dataset[var]) |>
    knitr::kable()
}
```

The function above uses the `table()` function to create frequency tables,
and then this gets passed to the `knitr::kable()` function that produces
a good looking table for our rendered document:

```{r}
create_table(mtcars, "am")
```

Let’ suppose that we want to generate a document that would look like this:

- first a section title, with the name of the variable of interest
- then the table

So it would look like this:

## Frequency table for variable: "am"

```{r}
create_table(mtcars, "am")
```

We don’t want to create these sections for every variable by hand.

Instead, we can define a function that returns the R markdown code required
to create this. This is this function:

```{r}
return_section <- function(dataset, var){
  a <- knitr::knit_expand(text = c("## Frequency table for variable: {{variable}}",   
                                   create_table(dataset, var)),
                          variable = var)
  cat(a, sep = "\n")
}
```

This new function, `return_section()` uses `knitr::knit_expand()` to generate 
R Markdown code. Words between `{{}}` get replaced by the provided `var` argument
to the function. So when we call `return_section("am")`, `{{variable}}` is replaced
by `"am"`. `"am"` then gets passed down to `create_table()` and the frequency
table gets generated. We can now generate all the section by simply applying
our function to a list of column names:

```{r, results = "asis"}
invisible(lapply(colnames(mtcars), return_section, dataset = mtcars))
```

````

The last function, named `return_section()` uses `knitr::knit_expdand()`, which is the one
that does the heavy lifting. This section return literal R Markdown code. It returns 
`## Frequency table for variable: {{variable}}` which creates a level 2 section title 
with the text *Frequency table for variable: xxx* where the `xxx` will get replaced by 
the variabled passed to `return_section()`. So calling `return_section(mtcars, "am")` will
print the following in your console:


```
## Frequency table for variable: am
|am | Freq|
|:--|----:|
|0  |   19|
|1  |   13|
```

We now simply need to find a clever way to apply this function to each variable in the `mtcars` dataset.
For this, we are going to use `lapply()` which implements a for loop (you could use `purrr::map()`
just as well for this):

```{r, eval = FALSE}
invisible(lapply(colnames(mtcars), return_section, dataset = mtcars))
```

This will create, for each variable in `mtcars`, the same R Markdown code as above. Notice that the R Markdown
chunk where the call to `lapply()` is has the option `results = "asis"`. This is because the function
return literal Markdown code, and we don’t want the parser to have to evaluate it again, results in a mangled
result. We tell the parser "don’t worry about this bit of code, it’s already good". As you see, the call
to `lapply()` is wrapped inside `invisible()`. This is because `return_section()` does not return anything, it
just prints something to the console. No object is returned. So if you don’t wrap the call to `lapply()` inside
`invisible()`, then a bunch of `NULL`s will also get printed. To avoid this, use `invisible()` (and use 
`purrr::walk()` rather than `purrr::map()`).

Click [here](https://jolly-arithmetic-ce29cf.netlify.app/) to see the output.

This is not an easy topic, so take the time to play around with the example above. Try to print a plot instead 
of a table, try to generate more complex Markdown code, remove the call to `invisible()` and knit the document
and see what happens with the output, replace the call to `lapply()` with `purrr::walk()` or `purrr::map()`.
Really take the time to understand what is going on.

### Parametrized reports

## Project start

hpi: https://ec.europa.eu/eurostat/databrowser/bookmark/e2758aae-6a88-4684-9f6d-d0946cae3f6b?lang=fr

deflated hpi: https://ec.europa.eu/eurostat/databrowser/view/tipsho10/default/table?lang=en

prix des logements en euros courants: https://data.public.lu/fr/datasets/r/1d20f982-57e1-4ae2-a278-dc78c88c21dc

## Your project is done (?)

*So here the project is done, but actually it's just an Qmd file that gets compiled, so we would need
to explain why this is not enough, and motivate the readers to go the full way: developing packages,
using targets, and so on*
