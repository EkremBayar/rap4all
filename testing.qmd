# Testing your code

Testing code is crucial, and we all do it in some form or another. The problem
is that it is not something that we do consistently. Usually code gets tested in
the beginning of a project, but then, as we start focusing on the analysis more
and more and need to respect deadlines, testing gets forgotten.

In this chapter, you are going to learn how to make testing your code consistent
and, very importantly, fully automatic. Just like in the previous chapter, the 
key is to *write everything down*. Don’t just do a little test in the console
to see if the function you’ve just written works as expected. Write it down!
And don’t rely on future you to run tests, because future you is just as unreliable
as you are.

## Unit testing


## Assertive programming

The analysis is still in Quarto, so how could the readers of this book test their code?
Copying here what Miles wrote on the subject:

*‘Assertive programming’ is a topic that might be missing from the book. I think
of it as a kind of dual of unit testing. Unit testing is for more generally
applicable packaged code. But when you have functions in your analysis pipeline
that operate on a very specific kind of input data, unit testing becomes kind of
nonsensical because you’re left to dream up endless variations of your input
dataset that may never occur. It’s a bit easier to flip the effort to validating
the assumptions you have about your input and output data, which you can do in
the pipeline functions themselves rather than separate unit testing ones. This
is nice because it ensures the validation is performed in the pipeline run, and
so is backed by the same reproducibility guarantees.*

## Test-driven development

## Code coverage

